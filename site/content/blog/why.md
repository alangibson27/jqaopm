+++
title = "Why?"
draft = false
date = "2016-10-31T22:49:58Z"
tags = ["development"]
+++

There are plenty of perfectly adequate Spectrum emulators already freely available, so why did I feel the need to write
+F?

It did all start with the idea to make possible 2-player Spectrum gaming across a network - which, as far as I was
aware at the time I started out, wasn't possible in any other existing Spectrum emulator - but that wasn't my only
motivation.

Mainly, I wanted to learn, and to have a project of my own to sink my teeth into, experiment with, and give me a place
to have a go at applying things that I have read or thought about. Trust me, I learned a lot, and certainly a lot more
than I thought I might.

That's what this blog is about. I didn't set out to write a blog as a companion to +F or its site. A blog which simply
described a series of updates, bug fixes and new features on a project of no real significance would have been very
dull. Instead, I'm writing all of these blog posts after the fact, with (I expect) well over 90% of the work on +F
already complete. I'm able to put what I've learned into context for you, and hopefully you'll find what I'm presenting
to be helpful, informative and entertaining.

You may have noticed a theme emerging already - learning. That's what I've really enjoyed about +F. In truth, I've
barely actually used it for playing games. What have I learned? Obviously, an awful lot about the Z80's instruction
set, everything I hadn't realised I'd forgotten about two's complement binary, and how the innards of a Spectrum
function, among other.

Beyond that, though, I've been fascinated by how it seems to me that the fundamental laws of software development
apply anywhere and everywhere. Among others, and in no particular order, it's reinforced the reasons it's important
to have a clear vision of what you want your project to do; why you should write tests first; why it's really helpful
to understand what's happening beneath language abstractions; why prototyping is useful up-front but optimisation
should be left to the end.

None of these are at all novel, and in many cases they are principles which have been common software knowledge for
decades. In that respect, in what I do, I consider myself simply to be standing on the shoulders of the giants who
have gone before.